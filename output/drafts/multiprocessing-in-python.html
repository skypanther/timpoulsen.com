
<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="../theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="../theme/pygments/github.min.css">
  <link rel="stylesheet" type="text/css" href="../theme/css/main.css">
  <link rel="stylesheet" type="text/css" href="../theme/font-awesome/css/font-awesome.min.css">

    <link href="https://www.timpoulsen.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Tim Poulsen Atom">


  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/images/favicons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/images/favicons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicons/favicon-16x16.png">
  <link rel="manifest" href="/images/favicons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/images/favicons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="index, follow" />

    <!-- Chrome, Firefox OS and Opera -->
    <meta name="theme-color" content="#143742">
    <!-- Windows Phone -->
    <meta name="msapplication-navbutton-color" content="#143742">
    <!-- iOS Safari -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<meta name="author" content="Tim Poulsen" />
<meta name="description" content="Modern CPUs typically feature multiple cores, which in some sense is like having multiple computers at your disposal. By default, your Python code will run on one core. But when performance is critical, you can use multiple cores to run operations simultaneously. In this article, I'll walk through how we …" />
<meta name="keywords" content="python">
<meta property="og:site_name" content="Tim Poulsen"/>
<meta property="og:title" content="Multiprocessing in Python"/>
<meta property="og:description" content="Modern CPUs typically feature multiple cores, which in some sense is like having multiple computers at your disposal. By default, your Python code will run on one core. But when performance is critical, you can use multiple cores to run operations simultaneously. In this article, I'll walk through how we …"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="../drafts/multiprocessing-in-python.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2019-04-15 00:00:00-04:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="../author/tim-poulsen.html">
<meta property="article:section" content="Python"/>
<meta property="article:tag" content="python"/>
<meta property="og:image" content="/images/tim_poulsen.jpg">

  <title>Tim Poulsen &ndash; Multiprocessing in Python</title>


    <link href="/theme/css/main.css" rel="stylesheet">

</head>
<body>
  <aside class="leftbar" style="background-color: #030E36;">
    <div class="leftbar" style="background-color: #030E36;">
      <a href="..">
        <img src="/images/tim_poulsen.jpg" alt="Tim Poulsen" title="Tim Poulsen">
      </a>
      <h1><a href="..">Tim Poulsen</a></h1>

<p class="subtitle">Explorations of software and hardware</p>
      <ul class="social">
        <li><a class="sc-twitter" href="https://twitter.com/skypanther" target="_blank"><i class="fa fa-twitter"></i></a></li>
        <li><a class="sc-github" href="https://github.com/skypanther" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-linkedin" href="https://www.linkedin.com/in/timpoulsen" target="_blank"><i class="fa fa-linkedin"></i></a></li>
        <li><a class="sc-rss" href="feeds/all.atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li>
      </ul>

      <nav>
        <ul class="list">
          <li><a href="../pages/about.html#about">About</a></li>

          <li><a href="/categories.html" target="_blank">Topics</a></li>
          <li><a href="http://skypanther.com" target="_blank">Skypanther Studios</a></li>
        </ul>
      </nav>

      <p class="subhead">Tags:</p>
      <ul class="tagcloud">
          <li class="tag-1">
              <a href="../tag/python.html">
              python
              </a>
          </li>
          <li class="tag-1">
              <a href="../tag/opencv.html">
              opencv
              </a>
          </li>
          <li class="tag-2">
              <a href="../tag/raspberry-pi.html">
              raspberry pi
              </a>
          </li>
          <li class="tag-2">
              <a href="../tag/making.html">
              making
              </a>
          </li>
          <li class="tag-3">
              <a href="../tag/robotics.html">
              robotics
              </a>
          </li>
          <li class="tag-4">
              <a href="../tag/ios.html">
              iOS
              </a>
          </li>
          <li class="tag-4">
              <a href="../tag/swift.html">
              Swift
              </a>
          </li>
          <li class="tag-4">
              <a href="../tag/anaconda.html">
              anaconda
              </a>
          </li>
      </ul>

    </div>


  </aside>
  <main>

    <nav>
      <a href="..">    Home
</a>

      <a href="/categories.html">Topics</a>
      <a href="/pages/about.html">About</a>
      <a href="/tags.html">Tags</a>

      <a href="https://www.timpoulsen.com/feeds/all.atom.xml">    Atom
</a>

    </nav>

<article class="single">
  <header>
    <h1 id="multiprocessing-in-python">Multiprocessing in Python</h1>
    <p>
          Posted on Mon 15 April 2019 in <a href="../category/python.html">Python</a>


    </p>
  </header>


  <div>
    <p>Modern CPUs typically feature multiple cores, which in some sense is like having multiple computers at your disposal. By default, your Python code will run on one core. But when performance is critical, you can use multiple cores to run operations simultaneously. In this article, I'll walk through how we used multiprocessing in our FIRST Robotics code to run our scripts across all four cores of our Jetson TX2 board.</p>
<p>Python supports both multithreading and multiprocessing. Judging by the number of StackOverflow posts on the topic, there's a ton of confusion surrounding these terms. There are many <a href="https://realpython.com/python-concurrency/" target="_blank">articles</a> explaining the differences and nuances of multithreading and multiprocessing. Here's my take:</p>
<ul>
<li>Multithreading &mdash; run portions of your code <strong>asynchronously</strong> so that your script doesn't have to wait for <strong>I/O bound operations</strong>; but all your code runs on the same CPU core, and <strong>shares the same memory and variable space.</strong></li>
<li>Multiprocessing &mdash; run portions of your code <strong>simultaneously</strong> across multiple cores so that you script doesn't have to wait for <strong>CPU bound operations</strong>; because your code runs across multiple cores, each process has its own <strong>separate memory and variable space.</strong></li>
</ul>
<p>Use multithreading if your script needs to access data across the network, read a lot of data from disk, or do other I/O bound operations. Multithreading isn't really running code simultaneously. It's just not stopping everything while waiting for the I/O operation to finish. </p>
<p>Use multiprocessing if your script does a lot of computation, such as processing image frames from a webcam stream. You might employ multithreading to do the camera I/O. But multiprocessing would let you do the processing simultaneously with other code your script might perform. Sharing information between processes is more difficult since processes don't share memory or variables.</p>
<h2>Multiprocess-bot</h2>
<p>While we used both on our 2019 FRC bot, I'm going to focus on multiprocessing. Here are the tasks we programmed our Jetson to do:</p>
<ul>
<li>One process captured frames from an IP camera, did target identification and field orientation calculations, then wrote the results to NetworkTables so that the data was available to the robot and driver computers.</li>
<li>Another process captured frames from a pair of web cams, received data via a queue, and used that data to create custom overlays atop the video feeds. Then it streamed those processed feeds across the network to the driver computer.</li>
<li>And we had a third process that instantiated and managed those processes.</li>
</ul>
<h2>Starting multi-process scripts</h2>
<p>Let's start by seeing how we can start our multiple processes. (You might not want to actually run code like this till I cover how to stop the processes a bit later in this article.) In <a href="https://github.com/Raider-Robotics-Team-1518/Jetson/blob/master/parallelized/main.py" target="_blank">the main.py file</a>, we import the two custom classes of our bot program, and then call their <code>start()</code> methods:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># import our bot-specific classes</span>
<span class="kn">from</span> <span class="nn">camstreamer</span> <span class="kn">import</span> <span class="n">Camstreamer</span>
<span class="kn">from</span> <span class="nn">targeting</span> <span class="kn">import</span> <span class="n">Targeting</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">camstreamer_process</span> <span class="o">=</span> <span class="n">Camstreamer</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">target_process</span> <span class="o">=</span> <span class="n">Targeting</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

    <span class="n">camstreamer_process</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">target_process</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>That part looks pretty standard. The magic that enables multiprocessing is actually put in those custom classes. Let's take a look at the (simplified) code of the <a href="https://github.com/Raider-Robotics-Team-1518/Jetson/blob/master/parallelized/targeting.py" target="_blank">targeting.py script</a>: </p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span>

<span class="k">class</span> <span class="nc">Targeting</span><span class="p">(</span><span class="n">Process</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Targeting</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># other initialization stuff here</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># do the work of your class in this method</span>
</pre></div>
</td></tr></table>

<p>Some key points here: we import Process and then inherit from it when defining our class. This gives our class the capabilities to run as a distinct process. Then, as the first statement in our class's init method, we call the superclass's init method. For probably no good reason, I'm using the older Python 2.x syntax in that line. With Python 3.x, you can simplify that to <code>super().__init__()</code> (or use the older syntax). For more information on super(), check <a href="https://www.pythonforbeginners.com/super/working-python-super-function" target="_blank">here</a> and <a href="https://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods" target="_blank">here</a>.</p>
<p>As you saw above, we'll call our class's <code>start()</code> method to actually start the process. But you don't provide a start method in your subclass. Instead, you have to create a method named <code>run()</code>. The inherited start() method will call your run() method. It seems a little weird, but that's how it works.</p>
<h2>Pipes and Queues</h2>
<p>As I mentioned above, process don't share memory or variables. To communicate between processes, we need to use <a href="https://docs.python.org/3/library/multiprocessing.html#pipes-and-queues" target="_blank">pipes or queues</a>. Pipes are fast, one-way communication channels between a sender/receiver pair &mdash; put a message in at one end and it's immediately available at the other. Multiprocessing queues are two-way channels between multiple senders and receivers. They work like other FIFO queues you might be familiar with &mdash; the sender places a message onto the queue, the receiver pulls off the first-available message on the queue.</p>
<p>We used queues to share field / positional data between the processes. The targeting script would calculate its values and put them into the queue. The camera streamer class would pull values off the queue and use them in constructing the overlays. Let's see how that was accomplished.</p>
<p>In <a href="https://github.com/Raider-Robotics-Team-1518/Jetson/blob/master/parallelized/main.py" target="_blank">the main.py file</a>, we create the queue instance and pass it to each of the processes that will use it. In this way, each process has a reference to the queue in its memory space. (Only thread/process-safe constructs, like Pipes and Queues can be shared between processes like this.)</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Queue</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">targeting_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="n">camstreamer_process</span> <span class="o">=</span> <span class="n">Camstreamer</span><span class="p">(</span><span class="n">targeting_queue</span><span class="o">=</span><span class="n">targeting_queue</span> <span class="o">...</span><span class="p">)</span>
    <span class="n">target_process</span> <span class="o">=</span> <span class="n">Targeting</span><span class="p">(</span><span class="n">targeting_queue</span><span class="o">=</span><span class="n">targeting_queue</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>To write data to the queue, the <a href="https://github.com/Raider-Robotics-Team-1518/Jetson/blob/master/parallelized/targeting.py" target="_blank">targeting.py script</a> just needed to call <code>put()</code> on the queue reference passed to the class, like this:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">targeting_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">field_data</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Our bot's <a href="https://github.com/Raider-Robotics-Team-1518/Jetson/blob/master/parallelized/camstreamer.py" target="_blank">camera streamer class</a> read data from the queue. In that script, we used the <code>get_nowait()</code> method to read values from the queue. We could have used the <code>get()</code> method. However that function is blocking, meaning your script would pause till data was available on the queue. The <code>get_nowait()</code> method doesn't pause for data to be available, so it is faster. But it will throw an exception if there's nothing on the queue to read. To handle that, we just wrapped it in a try/except block, like this:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">field_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targeting_queue</span><span class="o">.</span><span class="n">get_nowait</span><span class="p">()</span>
    <span class="c1"># use the field data to draw the overlays</span>
    <span class="c1"># ...</span>
<span class="k">except</span> <span class="n">Empty</span><span class="p">:</span>
    <span class="c1"># exception thrown if there&#39;s nothing in the queue to read</span>
    <span class="k">pass</span>
</pre></div>
</td></tr></table>

<p>We probably could have used a pipe for this communication, since it was a one-way stream. But, a queue has the advantage of holding multiple values. So, if the sender script gets ahead, messages will still be available to be processed when the reader is available. Pipes pass just a single value. If a new one is written before the previous value is read it will "push" the first value out of the pipe.</p>
<h3>Stopping background processes</h3>
<p>Once a script is launched as a separate process, it will run till stopped (or you kill it at the operating system level). During the competition, we were fine with the scripts running till we shut down our Jetson board. But, that's not typically how you'd manage your multiprocessing scripts.</p>
<p>Classes that inherit from Process have a <code>terminate()</code> method. When called, it will abruptly halt the process. If you need to close connections or otherwise gracefully stop your script, you'll want to signal it that it's about to be terminated. Once the process finishes its cleanup, then you call terminate().</p>
<p>In our bot program, we implemented this signalling using Pipes. In main.py, we listened for the Escape or "q" key to be pressed. When that happened, we sent a message across each child process's pipe that a shutdown was imminent. The child scripts would then stop their actions and clean up. After a brief delay, main.py would terminate the processes.</p>
<p>Looking again at main.py:</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Queue</span><span class="p">,</span> <span class="n">Pipe</span>

<span class="n">stop_pipes</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">cs_reader</span><span class="p">,</span> <span class="n">cs_writer</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">duplex</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">trgt_reader</span><span class="p">,</span> <span class="n">trgt_writer</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">duplex</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">stop_pipes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cs_writer</span><span class="p">)</span>
    <span class="n">stop_pipes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trgt_writer</span><span class="p">)</span>
    <span class="n">targeting_queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="n">camstreamer_process</span> <span class="o">=</span> <span class="n">Camstreamer</span><span class="p">(</span><span class="n">targeting_queue</span><span class="o">=</span><span class="n">targeting_queue</span><span class="p">,</span> <span class="n">stop_pipe</span><span class="o">=</span><span class="n">cs_reader</span><span class="p">)</span>
    <span class="n">target_process</span> <span class="o">=</span> <span class="n">Targeting</span><span class="p">(</span><span class="n">targeting_queue</span><span class="o">=</span><span class="n">targeting_queue</span><span class="p">,</span> <span class="n">stop_pipe</span><span class="o">=</span><span class="n">trgt_reader</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
    <span class="o">...</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="c1"># wait for Esc or q key and then exit</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="mi">27</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">==</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">):</span>
            <span class="n">cv2</span><span class="o">.</span><span class="n">destroyAllWindows</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">pipe</span> <span class="ow">in</span> <span class="n">stop_pipes</span><span class="p">:</span>
                <span class="n">pipe</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;stop&quot;</span><span class="p">)</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">camstreamer_process</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
            <span class="n">target_process</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
            <span class="nb">exit</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>When instantiating a pipe, you get back a tuple whose values represent the read and write ends of the pipe. As shown in the snippet above, we created those pipe instances and passed the read ends to our child processes. In main.py's while loop, we use the write ends of the pipes (which were stored in a list) to put the string "stop" onto the pipe when the user signaled to quit.</p>
<p>In our child processes, all the computation was done inside an endless <code>while True:</code> loop. At the start of each iteration, we'd poll to see if data was available on the pipe. If so, and if it were the string "stop" we'd break out of the loop.</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop_pipe</span><span class="o">.</span><span class="n">poll</span><span class="p">():</span>
            <span class="c1"># try reading from the stop pipe; if it&#39;s not empty</span>
            <span class="c1"># this block will work, and we&#39;ll exit the while</span>
            <span class="c1"># loop and terminate the script</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop_pipe</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">stop</span> <span class="o">==</span> <span class="s2">&quot;stop&quot;</span><span class="p">:</span>
                <span class="k">break</span>
</pre></div>
</td></tr></table>

<p>Pipes are great for this sort of one-way communication. The main.py control script sent out stop messages, and the child messages listened for those messages.</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="../tag/python.html">python</a>
    </p>
  </div>




</article>

    <footer>
<p>
  &copy; Tim Poulsen 2019 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>    Powered by <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a>
</p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>





<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Tim Poulsen ",
  "url" : "..",
  "image": "/images/tim_poulsen.jpg",
  "description": "Tim Poulsen's blog of software, hardware, and life"
}
</script>
</body>
</html>